# main.py - Entry point, FastAPI setup (multi-strategy)
import logging
import os
from datetime import datetime
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request, Form, BackgroundTasks, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
import uvicorn
from typing import Optional

from config import DASHBOARD_PORT
from strategy_repository import StrategyRepository
from signal_processor import SignalProcessor
from cash_manager import CashManager
from cooldown_manager import CooldownManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('webhook.log')
    ]
)

logger = logging.getLogger(__name__)

# Initialize services
strategy_repo = StrategyRepository()
signal_processor = SignalProcessor()
cash_manager = CashManager()
cooldown_manager = CooldownManager()

@asynccontextmanager
async def lifespan(app):
    # Startup event
    logger.info("ðŸ”¥ SYSTEM STARTUP: Multi-Strategy Trading Webhook Service")
    
    # Ensure all existing strategies have proper attributes
    try:
        strategies = strategy_repo.get_all_strategies()
        logger.info(f"ðŸ”¥ SYSTEM STARTUP: Found {len(strategies)} existing strategies")
    except Exception as e:
        logger.error(f"ðŸ”¥ SYSTEM STARTUP: Error loading strategies: {e}")
    
    yield
    # Shutdown event
    logger.info("ðŸ”¥ SYSTEM SHUTDOWN: Multi-Strategy Trading Webhook Service")

# Initialize FastAPI
app = FastAPI(title="Multi-Strategy Trading Webhook Service", lifespan=lifespan)

# Setup templates and static files
templates = Jinja2Templates(directory="templates")
app.mount("/static", StaticFiles(directory="static"), name="static")

# Strategy-specific webhook endpoints
@app.post("/{strategy_name}/long")
async def webhook_long(strategy_name: str, request: Request, background_tasks: BackgroundTasks):
    """Webhook endpoint for long signals"""
    return await _process_webhook(strategy_name, "long", request, background_tasks)

@app.post("/{strategy_name}/short")
async def webhook_short(strategy_name: str, request: Request, background_tasks: BackgroundTasks):
    """Webhook endpoint for short signals"""
    return await _process_webhook(strategy_name, "short", request, background_tasks)

@app.post("/{strategy_name}/close")
async def webhook_close(strategy_name: str, request: Request, background_tasks: BackgroundTasks):
    """Webhook endpoint for close signals"""
    return await _process_webhook(strategy_name, "close", request, background_tasks)

async def _process_webhook(strategy_name: str, signal: str, request: Request, background_tasks: BackgroundTasks):
    """Process webhook signal for a specific strategy"""
    try:
        client_ip = request.client.host if request.client else "unknown"
        logger.info(f"ðŸ”¥ WEBHOOK RECEIVED: strategy={strategy_name} signal={signal} from_ip={client_ip}")
        
        # Get strategy
        strategy = strategy_repo.get_strategy(strategy_name)
        if not strategy:
            available_strategies = strategy_repo.get_strategy_names()
            error_response = {
                "status": "error",
                "error_type": "strategy_not_found", 
                "message": f"Strategy '{strategy_name}' not found",
                "available_strategies": available_strategies,
                "help": "Create this strategy first or check the strategy name in your webhook URL"
            }
            logger.error(f"ðŸ”¥ ERROR: strategy={strategy_name} not_found webhook_ignored")
            return JSONResponse(status_code=404, content=error_response)
        
        logger.info(f"ðŸ”¥ STRATEGY LOOKUP: found strategy={strategy.name} symbols={strategy.long_symbol}/{strategy.short_symbol} cash={strategy.cash_balance}")
        
        # Process signal in background to avoid webhook timeout
        background_tasks.add_task(signal_processor.process_signal, signal, strategy)
        
        return {"status": "processing", "strategy": strategy_name, "signal": signal}
        
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: strategy={strategy_name} webhook_processing_error={str(e)}")
        return JSONResponse(
            status_code=500, 
            content={
                "status": "error",
                "error_type": "internal_error",
                "message": str(e),
                "help": "Check server logs for details"
            }
        )

# Strategy management endpoints
@app.post("/strategies")
async def create_strategy(
    name: str = Form(...),
    long_symbol: Optional[str] = Form(None),
    short_symbol: Optional[str] = Form(None),
    cash_balance: float = Form(0.0)
):
    """Create a new strategy"""
    try:
        # Clean up symbol inputs
        long_symbol = long_symbol.strip() if long_symbol and long_symbol.strip() else None
        short_symbol = short_symbol.strip() if short_symbol and short_symbol.strip() else None
        
        strategy = strategy_repo.create_strategy(name, long_symbol, short_symbol, cash_balance)
        return {"status": "success", "strategy": strategy.to_dict()}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: create_strategy_error={str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/strategies")
async def list_strategies():
    """List all strategies"""
    strategies = strategy_repo.get_all_strategies()
    return {
        "strategies": [strategy.to_dict() for strategy in strategies],
        "count": len(strategies)
    }

@app.get("/strategies/{name}")
async def get_strategy(name: str):
    """Get a specific strategy"""
    strategy = strategy_repo.get_strategy(name)
    if not strategy:
        raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
    return {"strategy": strategy.to_dict()}

@app.put("/strategies/{name}")
async def update_strategy(
    name: str,
    long_symbol: Optional[str] = Form(None),
    short_symbol: Optional[str] = Form(None),
    cash_balance: Optional[float] = Form(None)
):
    """Update a strategy"""
    try:
        # Clean up symbol inputs
        if long_symbol is not None:
            long_symbol = long_symbol.strip() if long_symbol.strip() else None
        if short_symbol is not None:
            short_symbol = short_symbol.strip() if short_symbol.strip() else None
        
        strategy = strategy_repo.update_strategy(name, long_symbol, short_symbol, cash_balance)
        if not strategy:
            raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
        return {"status": "success", "strategy": strategy.to_dict()}
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: update_strategy_error={str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/strategies/{name}")
async def delete_strategy(name: str):
    """Delete a strategy"""
    success = strategy_repo.delete_strategy(name)
    if not success:
        raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
    return {"status": "success", "message": f"Strategy '{name}' deleted"}

# Strategy-specific operations
@app.post("/strategies/{name}/update-symbols")
async def update_strategy_symbols(
    name: str,
    long_symbol: str = Form(...),
    short_symbol: str = Form(...)
):
    """Update symbols for a specific strategy"""
    try:
        # Clean up inputs
        long_symbol = long_symbol.strip() if long_symbol.strip() else None
        short_symbol = short_symbol.strip() if short_symbol.strip() else None
        
        strategy = strategy_repo.update_strategy(name, long_symbol=long_symbol, short_symbol=short_symbol)
        if not strategy:
            raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
        return {"status": "success", "strategy": strategy.to_dict()}
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: update_symbols_error={str(e)}")
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/strategies/{name}/update-cash")
async def update_strategy_cash(name: str, cash_amount: float = Form(...)):
    """Update cash balance for a specific strategy"""
    try:
        strategy = strategy_repo.get_strategy(name)
        if not strategy:
            raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
        
        success = cash_manager.update_balance_manual(cash_amount, strategy)
        if not success:
            raise HTTPException(status_code=400, detail="Invalid cash amount")
        
        return {"status": "success", "strategy": strategy.to_dict()}
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: update_cash_error={str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/strategies/{name}/start-cooldown")
async def start_strategy_cooldown(name: str):
    """Start cooldown for a specific strategy"""
    try:
        strategy = strategy_repo.get_strategy(name)
        if not strategy:
            raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
        
        cooldown_manager.start_cooldown(strategy)
        return {"status": "success", "strategy": strategy.to_dict()}
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: start_cooldown_error={str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/strategies/{name}/stop-cooldown")
async def stop_strategy_cooldown(name: str):
    """Stop cooldown for a specific strategy"""
    try:
        strategy = strategy_repo.get_strategy(name)
        if not strategy:
            raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
        
        cooldown_manager.stop_cooldown(strategy)
        return {"status": "success", "strategy": strategy.to_dict()}
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: stop_cooldown_error={str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/strategies/{name}/force-long")
async def force_strategy_long(name: str, background_tasks: BackgroundTasks):
    """Force long position for a specific strategy"""
    try:
        strategy = strategy_repo.get_strategy(name)
        if not strategy:
            raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
        
        if strategy.is_processing:
            return {"status": "error", "message": "Strategy is already processing a signal"}
        
        background_tasks.add_task(signal_processor.force_long, strategy)
        return {"status": "success", "message": f"Force long initiated for strategy '{name}'"}
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: force_long_error={str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/strategies/{name}/force-short")
async def force_strategy_short(name: str, background_tasks: BackgroundTasks):
    """Force short position for a specific strategy"""
    try:
        strategy = strategy_repo.get_strategy(name)
        if not strategy:
            raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
        
        if strategy.is_processing:
            return {"status": "error", "message": "Strategy is already processing a signal"}
        
        background_tasks.add_task(signal_processor.force_short, strategy)
        return {"status": "success", "message": f"Force short initiated for strategy '{name}'"}
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: force_short_error={str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/strategies/{name}/force-close")
async def force_strategy_close(name: str, background_tasks: BackgroundTasks):
    """Force close all positions for a specific strategy"""
    try:
        strategy = strategy_repo.get_strategy(name)
        if not strategy:
            raise HTTPException(status_code=404, detail=f"Strategy '{name}' not found")
        
        if strategy.is_processing:
            return {"status": "error", "message": "Strategy is already processing a signal"}
        
        background_tasks.add_task(signal_processor.force_close, strategy)
        return {"status": "success", "message": f"Force close initiated for strategy '{name}'"}
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: force_close_error={str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Dashboard endpoints
@app.get("/", response_class=HTMLResponse)
async def dashboard(request: Request):
    """Multi-strategy dashboard"""
    strategies = strategy_repo.get_all_strategies()
    return templates.TemplateResponse(
        "index.html", 
        {
            "request": request,
            "strategies": [strategy.to_dict() for strategy in strategies]
        }
    )

# Legacy compatibility and utility endpoints
@app.get("/status")
async def status():
    """Get system status"""
    strategies = strategy_repo.get_all_strategies()
    return {
        "status": "ok",
        "system": "multi-strategy",
        "strategies": len(strategies),
        "strategy_names": [s.name for s in strategies]
    }

@app.post("/debug")
async def debug_log(request: Request):
    """Debug endpoint to log JavaScript activity"""
    try:
        payload = await request.json()
        message = payload.get("message", "No message")
        logger.info(f"ðŸ”¥ JAVASCRIPT DEBUG: {message}")
        return {"status": "logged", "message": message}
    except Exception as e:
        logger.info(f"ðŸ”¥ JAVASCRIPT DEBUG (text): {await request.body()}")
        return {"status": "logged"}

@app.get("/debug-test")
async def debug_test():
    """Simple debug test endpoint"""
    logger.info("ðŸ”¥ DEBUG TEST ENDPOINT CALLED - JavaScript is working!")
    return {"status": "success", "message": "Debug test successful"}

@app.post("/debug/clear-strategies")
async def debug_clear_strategies():
    """Debug endpoint to clear all strategies (use with caution!)"""
    try:
        with strategy_repo._storage_lock:
            count = len(strategy_repo.strategies)
            strategy_repo.strategies.clear()
            logger.info(f"ðŸ”¥ DEBUG: Cleared {count} strategies from repository")
        return {"status": "success", "message": f"Cleared {count} strategies", "count": count}
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: debug_clear_strategies_error={str(e)}")
        return {"status": "error", "message": str(e)}

@app.post("/debug/fix-strategies") 
async def debug_fix_strategies():
    """Debug endpoint to fix existing strategies missing display_name"""
    try:
        fixed_count = 0
        with strategy_repo._storage_lock:
            for strategy in strategy_repo.strategies.values():
                if not hasattr(strategy, 'display_name'):
                    strategy.display_name = strategy.name
                    fixed_count += 1
                    logger.info(f"ðŸ”¥ DEBUG: Fixed display_name for strategy {strategy.name}")
        
        return {"status": "success", "message": f"Fixed {fixed_count} strategies", "fixed_count": fixed_count}
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: debug_fix_strategies_error={str(e)}")
        return {"status": "error", "message": str(e)}

@app.get("/debug/strategies")
async def debug_strategies():
    """Debug endpoint to inspect strategy objects"""
    try:
        with strategy_repo._storage_lock:
            debug_info = []
            for name, strategy in strategy_repo.strategies.items():
                debug_info.append({
                    "name": name,
                    "has_display_name": hasattr(strategy, 'display_name'),
                    "display_name": getattr(strategy, 'display_name', 'MISSING'),
                    "attributes": list(dir(strategy))
                })
        return {"status": "success", "strategies": debug_info}
    except Exception as e:
        logger.exception(f"ðŸ”¥ ERROR: debug_strategies_error={str(e)}")
        return {"status": "error", "message": str(e)}

if __name__ == "__main__":
    port = int(os.environ.get("PORT", DASHBOARD_PORT))
    uvicorn.run("main:app", host="0.0.0.0", port=port, reload=False)
